<?php

/**
 * Created by PhpStorm.
 * User: User
 * Date: 2016-10-23
 * Time: 9:57 PM
 */

require_once ('Table.php');

abstract class GeneratedClass EXTENDS Table
{
    const FILTER_TYPE_NONE = 0;
    const FILTER_TYPE_BOOL = 1;
    const FILTER_TYPE_INT = 2;
    const FILTER_TYPE_FLOAT = 3;
    const FILTER_TYPE_STRING = 4;

    const ARRAY_TYPE_NUMERIC = 1;
    const ARRAY_TYPE_ASSOC = 2;
    const ARRAY_TYPE_BOTH = 3;

    protected $fields_excluded_globally = array('createdDateTime','modifiedDateTime');


    abstract protected function GetTableMetaAsAssocArray();

    /**
     * This function is to be used when a MySQL database is the source of data within inherited classes generated by "Helping-Developers-With-Class"
     * It returns bound parameter types to be used to virtually accomplish parameterized querying
     * @param string $listOfFields
     * @return string
     */
    public function GetBoundParamTypeString($listOfFields='*')
    {
        if ($listOfFields == '*')
            $listOfFields = $this->allFieldsWithoutKeys;
        $myMeta = $this->GetTableMetaAsAssocArray();
        $boundParamString = '';
        foreach ($listOfFields as $field) {
            if (array_key_exists($field, $myMeta)) {
                $boundParamString .= $myMeta[$field]['BOUND_PARAM_TYPE'];
            }
        }
        return $boundParamString;
    }


    /**
     * This function is primarily only invoked privately within inherited classes generated by "Helping-Developers-With-Class"
     * Its primary purpose is to return a list of name/value pairs when given a list of field names
     * @param string $listOfFields
     * @param bool $options --> still under construction
     * @return array
     */
    public function GetFieldsAsAssocArray($listOfFields='*', ...$options)
    {
        if ($listOfFields == '*')
            $listOfFields = $this->allFieldsWithoutKeys;

        if(isset($this->fields_excluded_locally)){
            $fieldsToAlwaysOmit= array_merge($this->fields_excluded_globally,$this->fields_excluded_locally);//Omitting these fields because of their auto-enter options (which will take care of themselves unless the field is explicitly written to)
        }elseif(isset($this->fields_excluded_globally)){
            $fieldsToAlwaysOmit = $this->fields_excluded_globally;
        }else{
            $fieldsToAlwaysOmit = array();
        }

        foreach($fieldsToAlwaysOmit as $omitItem){
            if(($key = array_search($omitItem, $listOfFields)) !== false) {
                unset($listOfFields[$key]);
            }
        }
        /*ToDo: Add a way to handle $options*/

        $tableMeta = $this->GetTableMetaAsAssocArray();//Retrieve metadata describing the fields in this table
        $result = array();
        foreach ($listOfFields as $myIndex => $fieldName) {//Loop through each of the fields requested, processing them individually
            if (property_exists($this, $fieldName)) {//Check to make sure that the field requested actually exists as a property to the current class
                $myValue = $this->$fieldName;
                $myMeta = $tableMeta[$fieldName];
                $result[$fieldName] = $this->ReturnFormattedData($myValue, $myMeta, true, false); //Sanitize Inputs
                if($result[$fieldName] instanceof Exception){
                    throw new Exception("Field: $fieldName --> " . $result[$fieldName]->getMessage());
                }
            }
            else{
                throw new Exception('User requested property ' . $fieldName . ', but no such property exists.');
            }
        }
        return $result;
    }

    /**
     * @param $data
     * @param $fieldMeta
     * @return int|mixed
     */
    protected function sanitizeInput($data, $fieldMeta){
        $filterType = $fieldMeta['FilterTypeNum'];
        switch($filterType){
            case $this::FILTER_TYPE_STRING:
                $data = strval($data);
                break;

            case $this::FILTER_TYPE_INT:
                $data =  intval($data);
                break;

            case $this::FILTER_TYPE_FLOAT:
                $max_length = isset($fieldMeta['MAX_LENGTH']) ? $fieldMeta['MAX_LENGTH'] : 0;  //Max length will have been passed in the format of "precision"."scale" (Precision = total number of digits, scale = number of digits after decimal)
                $max_decimals = substr(strrchr($max_length, "."), 1);
                $data = number_format((float)$data, $max_decimals, '.', ''); //Format the number as a float with the proper number of digits after the decimal
                break;

            case $this::FILTER_TYPE_BOOL:
                $data =  boolval($data) ? 1 : 0 ;
                break;
        }
        return $data;
    }

    /**
     * @param $data
     * @param $fieldMeta
     * @throws Exception
     */
    protected function checkForIllegalNulls($data, $fieldMeta){
        $boolAllowsNull = $fieldMeta['IS_NULLABLE'] ;
        $dataIsNull = is_null($data);

        if(!$boolAllowsNull && $dataIsNull){
            throw new Exception('Data failed null check');
        }
        return;
    }

    /**
     * @param $data
     * @param $fieldMeta
     * @throws Exception
     */
    protected function checkForAcceptableFieldLength($data, $fieldMeta)
    {
        $max_length = isset($fieldMeta['MAX_LENGTH']) ? $fieldMeta['MAX_LENGTH'] : 0;

        if ($fieldMeta['BOUND_PARAM_TYPE'] === 'd') { //In the event that this is a real number (float, decimal, double...)
            $segments = explode('.', $max_length); //Max length will have been passed in the format of "precision"."scale" (Precision = total number of digits, scale = number of digits after decimal)
            $max_allowed_total = $segments[0];
            $max_allowed_decimals = (count($segments) > 1)? $segments[1] : 0;
            $max_allowed_wholeNum = ($max_allowed_decimals) ? $max_allowed_total - $max_allowed_decimals : $max_allowed_total;
            $data_before = explode('.', $data)[0];

            if ($max_length > 0) {
                if (strlen($data_before) > $max_allowed_wholeNum) {
                    throw new Exception('Field will not accept as much data as user provided.');
                }
            }

        } else {
            $actual_length = strlen((string)$data);
            if ($max_length > 0 && $actual_length > $max_length) {
                throw new Exception('Field will not accept as much data as user provided.');
            }
        }

    }




    /**
     * This function is used for sanitizing data within inherited classes generated by "Helping-Developers-With-Class"
     * It probably won't get used much since parameterized queries are now in effect
     * It could probably use some more work if it is going to be used too
     * @param $data
     * @param $fieldMeta
     * @param bool $boolSanitize
     * @param bool $boolEncapsulateInQuotes
     * @return int|mixed|null|string
     */
    protected function ReturnFormattedData($data,$fieldMeta,$boolSanitize=false,$boolEncapsulateInQuotes=false){
        $boolIsDateOrTime = (stristr($fieldMeta['DATA_TYPE'],'date')!== FALSE || stristr($fieldMeta['DATA_TYPE'],'time')!== FALSE );
        $boolRequiresEscape = $fieldMeta['BoolQuoteWhenPopulating'];
        $boolIsNumeric = $fieldMeta['IS_NUMERIC'];
        $escapeChar = ($boolRequiresEscape && $boolEncapsulateInQuotes) ? $this::CHAR_ESCAPE_FIELD_VALUE : "";


        if ($fieldMeta['BOUND_PARAM_TYPE']=='s' && $data==''){ //Since CoreDB currently won't allow saving empty strings to 's' fields that don't allow NULLs, I should follow suit with my rules here too.
            $data=null;
        }


        if($boolSanitize && !is_null($data)){
            $data = $this->sanitizeInput($data,$fieldMeta);
        }

        try{
            $this->checkForIllegalNulls($data,$fieldMeta); //Will throw exception if it fails
        }catch(Exception $e){
            return $e;
        }

        try{
            $this->checkForAcceptableFieldLength($data,$fieldMeta); //Will throw exception if it fails
        }catch(Exception $e){
            return $e;
        }

        $data = ($boolIsNumeric && !is_numeric($data)) ? 'null' : $data;
        $data = ($boolIsDateOrTime && $data=='') ? null : $data;
        $data = $escapeChar.$data.$escapeChar ;
        return $data;
    }




}