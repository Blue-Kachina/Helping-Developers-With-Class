<?php

/**
 * Created by PhpStorm.
 * User: User
 * Date: 2016-10-23
 * Time: 9:57 PM
 */

require_once ('Table.php');

abstract class GeneratedClass EXTENDS Table
{
    const FILTER_TYPE_NONE = 0;
    const FILTER_TYPE_BOOL = 1;
    const FILTER_TYPE_INT = 2;
    const FILTER_TYPE_FLOAT = 3;
    const FILTER_TYPE_STRING = 4;

    const ARRAY_TYPE_NUMERIC = 1;
    const ARRAY_TYPE_ASSOC = 2;
    const ARRAY_TYPE_BOTH = 3;

    abstract protected function GetTableMetaAsAssocArray();


    /**
     * This function is to be used when a MySQL database is the source of data within inherited classes generated by "Helping-Developers-With-Class"
     * It returns bound parameter types to be used to virtually accomplish parameterized querying
     * @param string $listOfFields
     * @return string
     */
    public function GetBoundParamTypeString($listOfFields='*')
    {
        if ($listOfFields == '*')
            $listOfFields = $this->allFieldsWithoutKeys;
        $myMeta = $this->GetTableMetaAsAssocArray();
        $boundParamString = '';
        foreach ($listOfFields as $field) {
            if (array_key_exists($field, $myMeta)) {
                $boundParamString .= $myMeta[$field]['BOUND_PARAM_TYPE'];
            }
        }
        return $boundParamString;
    }


    /**
     * This function is primarily only invoked privately within inherited classes generated by "Helping-Developers-With-Class"
     * Its primary purpose is to return a list of values when given a list of field names
     * It contains a number of options that can be set via parameters
     * @param string $listOfFields
     * @param int $arrayType
     * @param bool $boolUseSanitizeFilters
     * @param bool $boolEncapsulateInQuotes
     * @param bool $boolIncludeEmpties
     * @param bool $boolIncludeNulls
     * @return array
     */
    public function GetFieldsAsAssocArray($listOfFields='*', ...$options)
    {
        if ($listOfFields == '*')
            $listOfFields = $this->allFieldsWithoutKeys;

        $fieldsToAlwaysOmit = array('createdDateTime','modifiedDateTime'); //Omitting these fields because of their auto-enter options (which will take care of themselves unless the field is explicitly written to)
        foreach($fieldsToAlwaysOmit as $omitItem){
            //unset($listOfFields[$omitItem]);
            if(($key = array_search($omitItem, $listOfFields)) !== false) {
                unset($listOfFields[$key]);
            }
        }
        /*ToDo: Add a way to handle $options*/

        $tableMeta = $this->GetTableMetaAsAssocArray();//Retrieve metadata describing the fields in this table
        $result = array();
        foreach ($listOfFields as $myIndex => $fieldName) {//Loop through each of the fields requested, processing them individually
            if (property_exists($this, $fieldName)) {//Check to make sure that the field requested actually exists as a property to the current class
                $myValue = $this->$fieldName;
                $myMeta = $tableMeta[$fieldName];
                $result[$fieldName] = $this->ReturnFormattedData($myValue, $myMeta, true, false); //Sanitize Inputs
                if($result[$fieldName] instanceof Exception){
                    throw new Exception("Field: $fieldName --> " . $result[$fieldName]->getMessage());
                }
            }
            else{
                throw new Exception('User requested property ' . $fieldName . ', but no such property exists.');
            }
        }
        return $result;
    }

    /**
     * @param $data
     * @param $fieldMeta
     * @return int|mixed
     */
    protected function sanitizeInput($data, $fieldMeta){
        $filterType = $fieldMeta['FilterTypeNum'];
        switch($filterType){
            case $this::FILTER_TYPE_STRING:
                $data = strval($data);
                break;

            case $this::FILTER_TYPE_INT:
                $data =  intval($data);
                break;

            case $this::FILTER_TYPE_FLOAT:
                $data =  floatval($data) ;
                break;

            case $this::FILTER_TYPE_BOOL:
                $data =  boolval($data) ? 1 : 0 ;
                break;
        }
        return $data;
    }

    /**
     * @param $data
     * @param $fieldMeta
     * @throws Exception
     */
    protected function checkForIllegalNulls($data, $fieldMeta){
        $boolAllowsNull = $fieldMeta['IS_NULLABLE'] ;
        $dataIsNull = is_null($data);

        if(!$boolAllowsNull && $dataIsNull){
            throw new Exception('Data failed null check');
        }
        return;
    }

    /**
     * @param $data
     * @param $fieldMeta
     * @throws Exception
     */
    protected function checkForAcceptableStringLength($data, $fieldMeta){
        $max_length = isset($fieldMeta['MAX_LENGTH'])?$fieldMeta['MAX_LENGTH']:0;

        if($fieldMeta['BOUND_PARAM_TYPE'] === 'd'){
            list($max_allowed_total,$max_allowed_decimals) = explode('.',$max_length);
            $max_allowed_wholeNum = ($max_allowed_decimals)?$max_allowed_total-$max_allowed_decimals:$max_allowed_total;
            list($data_before,$data_after) = explode('.',$data);

            if($max_length > 0 && (strlen($data_before) > $max_allowed_wholeNum || strlen($data_after) > $max_allowed_decimals)){
                throw new Exception('Field will not accept as much data as user provided.');
            }
        }
        else{
            $actual_length = strlen((string)$data);
            if($max_length > 0 && $actual_length > $max_length){
                throw new Exception('Field will not accept as much data as user provided.');
            }
        }

    }




    /**
     * This function is used for sanitizing data within inherited classes generated by "Helping-Developers-With-Class"
     * It probably won't get used much since parameterized queries are now in effect
     * It could probably use some more work if it is going to be used too
     * @param $data
     * @param $fieldMeta
     * @param bool $boolSanitize
     * @param bool $boolEncapsulateInQuotes
     * @return int|mixed|null|string
     */
    protected function ReturnFormattedData($data,$fieldMeta,$boolSanitize=false,$boolEncapsulateInQuotes=false){
        $boolIsDateOrTime = (stristr($fieldMeta['DATA_TYPE'],'date')!== FALSE || stristr($fieldMeta['DATA_TYPE'],'time')!== FALSE );
        $boolRequiresEscape = $fieldMeta['BoolQuoteWhenPopulating'];
        $boolIsNumeric = $fieldMeta['IS_NUMERIC'];
        $escapeChar = ($boolRequiresEscape && $boolEncapsulateInQuotes) ? $this::CHAR_ESCAPE_FIELD_VALUE : "";

        if($boolSanitize && !is_null($data)){
            $data = $this->sanitizeInput($data,$fieldMeta);
        }

        try{
            $this->checkForIllegalNulls($data,$fieldMeta); //Will throw exception if it fails
        }catch(Exception $e){
            return $e;
        }

        try{
            $this->checkForAcceptableStringLength($data,$fieldMeta); //Will throw exception if it fails
        }catch(Exception $e){
            return $e;
        }

        $data = ($boolIsNumeric && !is_numeric($data)) ? 'null' : $data;
        $data = ($boolIsDateOrTime && $data=='') ? null : $data;
        $data = $escapeChar.$data.$escapeChar ;
        return $data;
    }




}