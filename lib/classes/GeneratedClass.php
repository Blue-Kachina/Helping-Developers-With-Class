<?php

/**
 * Created by PhpStorm.
 * User: User
 * Date: 2016-10-23
 * Time: 9:57 PM
 */

require_once ('Table.php');
require_once (__DIR__ . '/../../../conn.inc.php');

abstract class GeneratedClass //EXTENDS Table
{
    const FILTER_TYPE_NONE = 0;
    const FILTER_TYPE_BOOL = 1;
    const FILTER_TYPE_INT = 2;
    const FILTER_TYPE_FLOAT = 3;
    const FILTER_TYPE_STRING = 4;

    const ARRAY_TYPE_NUMERIC = 1;
    const ARRAY_TYPE_ASSOC = 2;
    const ARRAY_TYPE_BOTH = 3;

    protected $fields_excluded_globally = array('createdDateTime','modifiedDateTime');

    /**
     * @return mixed
     */
    abstract protected function GetTableMetaAsAssocArray();

    /**
     * @param $row
     */
    public function loadFromArray($row) {
        foreach($row as $key => $value){
            if(property_exists($this, $key)){
                $this->$key = $value;
            }
        }
    }

    /**
     * This function is to be used when a MySQL database is the source of data within inherited classes generated by "Helping-Developers-With-Class"
     * It returns bound parameter types to be used to virtually accomplish parameterized querying
     * @param string $listOfFields
     * @return string
     */
    public function GetBoundParamTypeString($listOfFields='*')
    {
        if ($listOfFields == '*')
            $listOfFields = $this->GetListOfFields();
        $myMeta = $this->GetTableMetaAsAssocArray();
        $boundParamString = '';
        foreach ($listOfFields as $field) {
            if (array_key_exists($field, $myMeta)) {
                $boundParamString .= $myMeta[$field]['BOUND_PARAM_TYPE'];
            }
        }
        return $boundParamString;
    }

    /**
     * @param string $startingList
     * @param bool $boolUseExplicitExcludes
     * @param bool $boolExcludeAutoIncrementing
     * @param bool $boolExcludeAllPrimaryKeys
     * @return array|string
     * @throws Exception
     */
    public function GetListOfFields($startingList='*', $boolUseExplicitExcludes=true, $boolExcludeAutoIncrementing=true, $boolExcludeAllPrimaryKeys=false){
        //Ensure that we have a valid $startingList
        if($startingList=='*'){
            if(isset($this->allFieldNames) && count($this->allFieldNames)){
                $startingList=$this->allFieldNames;
            }else{
                throw new Exception('No values found in $allFieldNames');
            }
        }elseif($startingList=='' || !count($startingList)){
            throw new Exception('Empty $startingList.  Cannot proceed with GetListOfFields');
        }

        //Omit the fields that were explicitly excluded (from global and/or local list)
        if($boolUseExplicitExcludes){
            if(isset($this->fields_excluded_locally)){
                $fieldsToAlwaysOmit= array_merge($this->fields_excluded_globally,$this->fields_excluded_locally);//Omitting these fields because of their auto-enter options (which will take care of themselves unless the field is explicitly written to)
            }elseif(isset($this->fields_excluded_globally)){
                $fieldsToAlwaysOmit = $this->fields_excluded_globally;
            }else{
                $fieldsToAlwaysOmit = array();
            }
            $startingList=array_diff($startingList,$fieldsToAlwaysOmit);
        }

        //Omit AutoIncrementing Fields
        if($boolExcludeAutoIncrementing){
            if(isset($this->AUTOINCREMENT) && count($this->AUTOINCREMENT)){
                $fieldsToOmit = $this->AUTOINCREMENT;
            }
            $startingList=array_diff($startingList,$fieldsToOmit);
        }

        //Omit ALL Primary Key fields
        if($boolExcludeAllPrimaryKeys){
            if(isset($this->PRIMARYKEY) && count($this->PRIMARYKEY)){
                $fieldsToOmit = $this->PRIMARYKEY;
            }
            $startingList=array_diff($startingList,$fieldsToOmit);
        }

        return $startingList;

    }

    /**
     * This function is primarily only invoked privately within inherited classes generated by "Helping-Developers-With-Class"
     * Its primary purpose is to return a list of name/value pairs when given a list of field names
     * @param string $listOfFields
     * @param $options --> still under construction
     * @return array
     */
    public function GetFieldsAsAssocArray($listOfFields='*')
    {
        if ($listOfFields == '*')
            $listOfFields = $this->GetListOfFields();
        /*ToDo: Add a way to handle $options*/

        $tableMeta = $this->GetTableMetaAsAssocArray();//Retrieve metadata describing the fields in this table
        $result = array();
        foreach ($listOfFields as $myIndex => $fieldName) {//Loop through each of the fields requested, processing them individually
            if (property_exists($this, $fieldName)) {//Check to make sure that the field requested actually exists as a property to the current class
                $myValue = $this->$fieldName;
                $myMeta = $tableMeta[$fieldName];
                $result[$fieldName] = $this->ReturnFormattedData($myValue, $myMeta, true, false); //Sanitize Inputs
                if($result[$fieldName] instanceof Exception){
                    throw new Exception("Field: $fieldName --> " . $result[$fieldName]->getMessage());
                }
            }
            else{
                throw new Exception('User requested property ' . $fieldName . ', but no such property exists.');
            }
        }
        return $result;
    }

    /**
     * @param $data
     * @param $fieldMeta
     * @return int|mixed
     */
    protected function sanitizeInput($data, $fieldMeta){
        $filterType = $fieldMeta['FilterTypeNum'];
        switch($filterType){
            case $this::FILTER_TYPE_STRING:
                $data = strval($data);
                break;

            case $this::FILTER_TYPE_INT:
                $data =  intval($data);
                break;

            case $this::FILTER_TYPE_FLOAT:
                $max_length = isset($fieldMeta['MAX_LENGTH']) ? $fieldMeta['MAX_LENGTH'] : 0;  //Max length will have been passed in the format of "precision"."scale" (Precision = total number of digits, scale = number of digits after decimal)
                $max_decimals = substr(strrchr($max_length, "."), 1);
                $data = number_format((float)$data, $max_decimals, '.', ''); //Format the number as a float with the proper number of digits after the decimal
                break;

            case $this::FILTER_TYPE_BOOL:
                $data =  boolval($data) ? 1 : 0 ;
                break;
        }
        return $data;
    }

    /**
     * @param $data
     * @param $fieldMeta
     * @throws Exception
     */
    protected function checkForIllegalNulls($data, $fieldMeta){
        $boolAllowsNull = $fieldMeta['IS_NULLABLE'] ;
        $dataIsNull = is_null($data);

        if(!$boolAllowsNull && $dataIsNull){
            throw new Exception('Data failed null check');
        }
        return;
    }

    /**
     * @param $data
     * @param $fieldMeta
     * @throws Exception
     */
    protected function checkForAcceptableFieldLength($data, $fieldMeta)
    {
        $max_length = isset($fieldMeta['MAX_LENGTH']) ? $fieldMeta['MAX_LENGTH'] : 0;

        if ($fieldMeta['BOUND_PARAM_TYPE'] === 'd') { //In the event that this is a real number (float, decimal, double...)
            $segments = explode('.', $max_length); //Max length will have been passed in the format of "precision"."scale" (Precision = total number of digits, scale = number of digits after decimal)
            $max_allowed_total = $segments[0];
            $max_allowed_decimals = (count($segments) > 1)? $segments[1] : 0;
            $max_allowed_wholeNum = ($max_allowed_decimals) ? $max_allowed_total - $max_allowed_decimals : $max_allowed_total;
            $data_before = explode('.', $data)[0];

            if ($max_length > 0) {
                if (strlen($data_before) > $max_allowed_wholeNum) {
                    throw new Exception('Field will not accept as much data as user provided.');
                }
            }

        } else {
            $actual_length = strlen((string)$data);
            if ($max_length > 0 && $actual_length > $max_length) {
                throw new Exception('Field will not accept as much data as user provided.');
            }
        }

    }

    /**
     * This function is used for sanitizing data within inherited classes generated by "Helping-Developers-With-Class"
     * It probably won't get used much since parameterized queries are now in effect
     * It could probably use some more work if it is going to be used too
     * @param $data
     * @param $fieldMeta
     * @param bool $boolSanitize
     * @return int|mixed|null|string
     */
    protected function ReturnFormattedData($data,$fieldMeta,$boolSanitize=false){
        $boolIsDateOrTime = (stristr($fieldMeta['DATA_TYPE'],'date')!== FALSE || stristr($fieldMeta['DATA_TYPE'],'time')!== FALSE );
        $boolIsNumeric = $fieldMeta['IS_NUMERIC'];

        if ($fieldMeta['BOUND_PARAM_TYPE']=='s' && $data==''){ //Since CoreDB currently won't allow saving empty strings to 's' fields that don't allow NULLs, I should follow suit with my rules here too.
            $data=null;
        }

        if($boolSanitize && !is_null($data)){
            $data = $this->sanitizeInput($data,$fieldMeta);
        }

        try{
            $this->checkForIllegalNulls($data,$fieldMeta); //Will throw exception if it fails
        }catch(Exception $e){
            return $e;
        }

        try{
            $this->checkForAcceptableFieldLength($data,$fieldMeta); //Will throw exception if it fails
        }catch(Exception $e){
            return $e;
        }

        $data = ($boolIsNumeric && !is_numeric($data)) ? 'null' : $data;
        $data = ($boolIsDateOrTime && $data=='') ? null : $data;
        return $data;
    }

    /**
     * @param $nameToQuote
     * @return string
     */
    public function quoteFieldOrTableName($nameToQuote){
        $escapeCharPre = $this::CHAR_ESCAPE_FIELD_NAME_PRE ;
        $escapeCharPost = $this::CHAR_ESCAPE_FIELD_NAME_POST ;
        return $escapeCharPre . $nameToQuote . $escapeCharPost ;
    }

    /**
     * @param $valueToQuote
     * @return string
     */
    public function quoteValue($valueToQuote){
        $escapeChar = $this::CHAR_ESCAPE_FIELD_VALUE ;
        return $escapeChar . $valueToQuote . $escapeChar ;
    }

    /**
     * @param $primaryKeyData
     * @return bool
     * @throws Exception
     */
    public function load($primaryKeyData){
        //Depending on the PRIMARYKEY of the table in question, this function's parameter could be a single value, or could even be an assoc array of field/value pairs
        $numPrimaryKeys = count($this->PRIMARYKEY);

        if(empty($primaryKeyData)){ //An empty value was passed as a parameter
            throw new Exception('Empty parameter passed to Load() function');
        }elseif (!is_array($primaryKeyData) && $numPrimaryKeys > 1){ //Only one value was passed in as a parameter, when multiple were expected
            throw new Exception('Only one value was passed to Load() function when this class expects data for multiple primary keys');
        }elseif(!is_array($primaryKeyData)){ // A single value was passed in, and that's good because the table in question only has one primary key
            $primaryKeyData = array($this->PRIMARYKEY[0]=>$primaryKeyData);
        }elseif($numPrimaryKeys != count($primaryKeyData)){ //An unexpected number of values were passed into this function as a parameter
            throw new Exception(count($primaryKeyData) . " values were passed to Load() function when this class expects " . $numPrimaryKeys);
        }

        $where = 'WHERE ' . implode('=? AND ', $primaryKeyData). ' = ?'; //Create "WHERE fieldName1=? AND fieldName2=?" string
        $keyValues = array_values($primaryKeyData);
        $pk_boundParamType = $this->GetBoundParamTypeString($this->PRIMARYKEY); // Will get a string like 'issddi' --> useful for MySQL/CoreDB parameterized queries
        $tableName = $this->quoteFieldOrTableName($this->TABLENAME); //Get tablename and escape it

        $db = get_db_connection();
        $sql = "SELECT * FROM $tableName $where";
        $rs = $db->query($sql, null, null, array_merge([$pk_boundParamType],$keyValues));

        if($rs) {
            //ToDo: Add a way to handle when multiple rows are found
            if($rs->rowCount()){
                $row = $rs->fetch(CoreDB::FETCH_ASSOC);
                $this->loadFromArray($row);
                return true;
            }else{
                return false;
            }
        }
        return false;
    }

    /**
     * Will attempt to save the current record.  Can throw exceptions, so please try() your save()
     * An INSERT will be performed if the primary key for $this is not already populated
     * An UPDATE will be performed otherwise
     * Various options will be available within the function --> still under construction(ie. sanitize,quote,includeEmpties,includeNulls)
     * @param string/array $listOfFields --> determines which fields are to be saved (single fieldname string or indexed array of fieldnames)
     * @return bool
     */
    public function save($listOfFields = "*") {
        //If user passes *, then we'll attempt to save all columns (except for the primary key(s)) to the database
        if ($listOfFields=='*'){
            $listOfFields=$this->GetListOfFields();
        }
        elseif(!is_array($listOfFields)){
            $listOfFields = array((string)$listOfFields); //In the event that only a fieldname was passed as a parameter (instead of an array), then we'll turn it into an array so we can continue anyway
        }
        $db = get_db_connection();
        //Create an assoc array of all the values we're about to save
        $nameValuePairs = $this->GetFieldsAsAssocArray($listOfFields); //Will remove the fields that are supposed to be excluded, and will even sanitize the data.
        $field_values = array_values($nameValuePairs);
        $field_names = array_keys($nameValuePairs);

        if(DB_DRIVER=='mysql')
            array_unshift($field_values,$this->GetBoundParamTypeString($field_names));

        $primaryKeyData = array();
        foreach($this->PRIMARYKEY as $fieldName){
            $primaryKeyData[$fieldName]=$this->$fieldName;
        }
        $pkValues = array_values($primaryKeyData);
        $autoIncrementFieldName = $this->AUTOINCREMENT[0];
        $boolAllPrimaryKeysHaveValues = count(array_filter($primaryKeyData)) == count($this->PRIMARYKEY);
        $boolNoPrimaryKeysHaveValues = count(array_filter($primaryKeyData)) == 0;

        if(!$boolAllPrimaryKeysHaveValues && !$boolNoPrimaryKeysHaveValues){
            throw new Exception('Not all primary keys have a value in "this" object.  Not sure if INSERT or UPDATE is required, and so program was aborted.');
        }

        $field_esc_pre = $this::CHAR_ESCAPE_FIELD_NAME_PRE;
        $field_esc_post = $this::CHAR_ESCAPE_FIELD_NAME_POST;

        if ($boolNoPrimaryKeysHaveValues) {
            //INSERT new record when this class's primary key property is empty
            $sql = "INSERT INTO $field_esc_pre{$this->TABLENAME}$field_esc_post".
                " ($field_esc_pre".implode("$field_esc_post, $field_esc_pre", $field_names )."$field_esc_post)" . //Comma Separated list of escaped field names
                ' VALUES ('. str_repeat ( '?,' , count($field_names)-1) .'?) ';

            //file_put_contents('c:/temp/phplog.txt',$sql);
            $rs = $db->query($sql, null, null, $field_values);
            if ($rs) {
                $this->$autoIncrementFieldName = $db->insertID();
                return true;
            } else {
                return false;
            }
        }else{
            $where = 'WHERE ' . implode('=? AND ', array_keys($primaryKeyData)). ' = ?';

            //UPDATE existing record based on this class's primary key
            $sql = "UPDATE $field_esc_pre{$this->TABLENAME}$field_esc_post SET " .
                "$field_esc_pre".implode("$field_esc_post=?, $field_esc_pre", $field_names ) . "$field_esc_post=? " .//Comma Separated list of escaped field names.  Each field=?
                "   $where";
            if(DB_DRIVER=='mysql')
                $field_values[0] = $field_values[0] . $this->GetBoundParamTypeString($this->PRIMARYKEY); //Since we're about to add PRIMARYKEY's values ($pkValues), we'll need to append their 'iissdd'
            $field_values = array_merge($field_values,$pkValues);
            $rs = $db->query($sql, null, null, $field_values);
            if ($rs) {
                if(count($this->$autoIncrementFieldName)){ //If an auto-incrementing field exists in this table
                    $this->$autoIncrementFieldName =  $db->insertID(); //Then set it equal to the newly generated ID
                }
                return true;
            } else {
                return false;
            }
        }
    }



}